Checked Possibilities:
- Different spectra from NIS
- Different transmittance
- spherical albedo
- Path radiance
- mu

- Problem seems to be with asd reference spectrum, unsure what --> SOLVED
tarp03_r = super_resample(mean(tarp03,1),asd_wvl,neon_wvl,neon_fwhm)'./100;
tarp3_asd08 = super_resample(mean(tarp03,1)',asd_wvl,neon_wvl,neon_fwhm)./100;

 -- In tarp03_r mean(tarp03,1) and asd_wvl have dimensions [1x2151]
      while neon_wvl and neon_fwhm have dimension [152x1]
 -- While in tarp03_asd08, all inputs are in [2151x1] or [152x1] there should be
      no difference in results but there must be some error in super_resample
      that is dependent on this. While in Python they are vectors [2151,] and
      [152,] so there is not ambiguity.

-  Fixed by moving transpose(') inside of super_resample called

- Fixed calc_rmse problem, **2 was outside of sum instead of inside

  Next Problem:
    Now Standard RMSE values match, still difference in Enhanced, and Enhanced
    with Adjacency need to compare spectra

    - Checked Spectra - they match
    - check reference tarp, they match
    - transmittance is the same

  Need to do time matching in solving function? - Added time matching function,
    it made very little difference
    - Rad0 -- Doesn't match because of rho_a_R
    - Idn?

    X baseline_flx['downwelling'] = baseline_flx['downwelling_direct'], not sure why
    - Fixed Error in modtran_tools.load_flx() that gave inccorrect values for downwelling Irradiance

Still difference in rho_a_R

FOUND ERRORS
- was resampling to neon_wvl instead of just truncating to the correct indices,
    replaced:
      spectrum = super_resample(...)
    with:
      spectrum = obs['spectra'][n,0:152]
- I verified that after the above fix the mean reflectance values were the same
  between python and matlab/octave
- plot_results() was already taking the averages, fixed so it will plot
  averages without affecting subsequent code
- Added averaging to calc_rmse() to exactly replicate matlab function
